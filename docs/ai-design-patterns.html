<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Agent - AI Design Patterns & Concepts</title>
    <style>
        :root {
            --primary: #8b5cf6;
            --primary-dark: #7c3aed;
            --secondary: #06b6d4;
            --accent: #f59e0b;
            --success: #10b981;
            --danger: #ef4444;
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --bg-card-hover: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.7;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 60px;
            padding: 50px 40px;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            border-radius: 24px;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 15px;
            position: relative;
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Navigation */
        .nav {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 40px;
            border: 1px solid var(--border);
            position: sticky;
            top: 20px;
            z-index: 100;
        }

        .nav h3 {
            margin-bottom: 15px;
            color: var(--primary);
            font-size: 1rem;
        }

        .nav-links {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .nav-link {
            background: var(--bg-dark);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 8px;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .nav-link:hover {
            background: var(--primary);
            color: white;
        }

        /* Pattern Card */
        .pattern {
            background: var(--bg-card);
            border-radius: 20px;
            margin-bottom: 40px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .pattern-header {
            padding: 30px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        .pattern-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
        }

        .pattern-title {
            flex-grow: 1;
        }

        .pattern-title h2 {
            font-size: 1.6rem;
            margin-bottom: 8px;
        }

        .pattern-title .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag {
            background: var(--bg-dark);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            color: var(--secondary);
        }

        .pattern-body {
            padding: 30px;
        }

        .pattern-section {
            margin-bottom: 30px;
        }

        .pattern-section:last-child {
            margin-bottom: 0;
        }

        .pattern-section h3 {
            color: var(--primary);
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pattern-section h3::before {
            content: '‚ñ∏';
            color: var(--secondary);
        }

        .pattern-section p {
            color: var(--text-secondary);
            margin-bottom: 15px;
        }

        /* Lists */
        .benefit-list {
            list-style: none;
            display: grid;
            gap: 10px;
        }

        .benefit-list li {
            background: var(--bg-dark);
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .benefit-list li::before {
            content: '‚úì';
            color: var(--success);
            font-weight: bold;
            flex-shrink: 0;
        }

        /* Code Block */
        .code-block {
            background: #0d1117;
            border-radius: 12px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            border: 1px solid var(--border);
        }

        .code-block .comment { color: #6a737d; }
        .code-block .keyword { color: #ff7b72; }
        .code-block .string { color: #a5d6ff; }
        .code-block .function { color: #d2a8ff; }
        .code-block .decorator { color: #79c0ff; }
        .code-block .class { color: #ffa657; }

        /* Diagram */
        .diagram {
            background: var(--bg-dark);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .diagram-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .diagram-box {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 15px 25px;
            min-width: 140px;
        }

        .diagram-box.highlight {
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            border: none;
        }

        .diagram-box h4 {
            font-size: 0.95rem;
            margin-bottom: 5px;
        }

        .diagram-box span {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .diagram-box.highlight span {
            color: rgba(255,255,255,0.8);
        }

        .diagram-arrow {
            color: var(--primary);
            font-size: 1.5rem;
        }

        .diagram-arrow-down {
            font-size: 1.5rem;
            color: var(--primary);
        }

        /* Comparison Table */
        .comparison {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison th,
        .comparison td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .comparison th {
            background: var(--bg-dark);
            color: var(--primary);
            font-weight: 600;
        }

        .comparison td {
            color: var(--text-secondary);
        }

        .comparison tr:hover td {
            background: rgba(139, 92, 246, 0.05);
        }

        /* Info Box */
        .info-box {
            background: rgba(139, 92, 246, 0.1);
            border-left: 4px solid var(--primary);
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .info-box.warning {
            background: rgba(245, 158, 11, 0.1);
            border-color: var(--accent);
        }

        .info-box.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--success);
        }

        .info-box h4 {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-box p {
            color: var(--text-secondary);
            margin: 0;
        }

        /* Interview Q&A */
        .qa-section {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }

        .qa-item {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid var(--border);
        }

        .qa-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .question {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .question::before {
            content: 'Q:';
            background: var(--accent);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .answer {
            color: var(--text-secondary);
            padding-left: 35px;
        }

        /* Summary Section */
        .summary-section {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(6, 182, 212, 0.2) 100%);
            border-radius: 20px;
            padding: 40px;
            margin-top: 40px;
        }

        .summary-section h2 {
            text-align: center;
            margin-bottom: 30px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .summary-item {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
        }

        .summary-item h3 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .summary-item p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 40px;
            margin-top: 60px;
            border-top: 1px solid var(--border);
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .pattern-header {
                flex-direction: column;
                text-align: center;
            }

            .diagram-row {
                flex-direction: column;
            }

            .diagram-arrow {
                transform: rotate(90deg);
            }

            .nav {
                position: static;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>üß† AI Design Patterns & Concepts</h1>
            <p class="subtitle">Deep dive into the AI architecture, design patterns, and concepts used in Code Agent - Perfect for interview preparation</p>
        </header>

        <!-- Navigation -->
        <nav class="nav">
            <h3>üìë Quick Navigation</h3>
            <div class="nav-links">
                <a href="#agent-pattern" class="nav-link">Agent Pattern</a>
                <a href="#tool-use" class="nav-link">Tool Use (Function Calling)</a>
                <a href="#rag" class="nav-link">RAG Pattern</a>
                <a href="#memory" class="nav-link">Memory Systems</a>
                <a href="#orchestration" class="nav-link">Orchestration</a>
                <a href="#streaming" class="nav-link">Streaming</a>
                <a href="#prompt-engineering" class="nav-link">Prompt Engineering</a>
                <a href="#interview-qa" class="nav-link">Interview Q&A</a>
            </div>
        </nav>

        <!-- Pattern 1: Agent Pattern -->
        <section id="agent-pattern" class="pattern">
            <div class="pattern-header">
                <div class="pattern-icon">ü§ñ</div>
                <div class="pattern-title">
                    <h2>1. Agentic AI Pattern</h2>
                    <div class="tags">
                        <span class="tag">Core Pattern</span>
                        <span class="tag">Autonomous</span>
                        <span class="tag">Goal-Oriented</span>
                    </div>
                </div>
            </div>
            <div class="pattern-body">
                <div class="pattern-section">
                    <h3>What is an AI Agent?</h3>
                    <p>An AI Agent is a system that can <strong>perceive its environment</strong>, make <strong>autonomous decisions</strong>, and take <strong>actions</strong> to achieve specific goals. Unlike simple chatbots that just respond, agents can:</p>
                    <ul class="benefit-list">
                        <li>Plan multi-step tasks and break them into smaller actions</li>
                        <li>Execute tools and commands autonomously</li>
                        <li>Adapt based on results and feedback</li>
                        <li>Maintain state and context across interactions</li>
                    </ul>
                </div>

                <div class="pattern-section">
                    <h3>How We Implement It</h3>
                    <p>Code Agent uses the <strong>Agno framework</strong> to create an agentic system:</p>
                    <div class="code-block">
<pre><span class="keyword">from</span> agno.agent <span class="keyword">import</span> Agent
<span class="keyword">from</span> agno.models.anthropic <span class="keyword">import</span> Claude

<span class="comment"># Define the agent with its capabilities</span>
agent = <span class="class">Agent</span>(
    name=<span class="string">"CodeAgent"</span>,
    model=<span class="function">get_model</span>(),              <span class="comment"># LLM brain</span>
    instructions=SYSTEM_PROMPT,       <span class="comment"># Behavior guidelines</span>
    tools=[                           <span class="comment"># Available actions</span>
        read_file, write_file,
        run_terminal_command,
        search_files, git_commit
    ],
    session_id=session_id,           <span class="comment"># Memory persistence</span>
    stream=<span class="keyword">True</span>                      <span class="comment"># Real-time output</span>
)</pre>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Agent Loop (ReAct Pattern)</h3>
                    <p>The agent follows the <strong>ReAct (Reasoning + Acting)</strong> pattern:</p>
                    <div class="diagram">
                        <div class="diagram-row">
                            <div class="diagram-box">
                                <h4>üì• Observe</h4>
                                <span>Receive input</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box highlight">
                                <h4>ü§î Think</h4>
                                <span>LLM reasoning</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box">
                                <h4>üîß Act</h4>
                                <span>Execute tool</span>
                            </div>
                        </div>
                        <div class="diagram-arrow-down">‚Üì</div>
                        <div class="diagram-row">
                            <div class="diagram-box">
                                <h4>üìä Observe Result</h4>
                                <span>Tool output</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box highlight">
                                <h4>ü§î Reflect</h4>
                                <span>Analyze result</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box">
                                <h4>üîÑ Continue/Complete</h4>
                                <span>Next action or done</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-box success">
                    <h4>üí° Why This Pattern?</h4>
                    <p>Agentic systems can handle complex, multi-step tasks that would be impossible for simple prompt-response systems. They can autonomously debug code, refactor projects, and manage entire development workflows.</p>
                </div>
            </div>
        </section>

        <!-- Pattern 2: Tool Use / Function Calling -->
        <section id="tool-use" class="pattern">
            <div class="pattern-header">
                <div class="pattern-icon">üîß</div>
                <div class="pattern-title">
                    <h2>2. Tool Use Pattern (Function Calling)</h2>
                    <div class="tags">
                        <span class="tag">LLM Extension</span>
                        <span class="tag">Action Execution</span>
                        <span class="tag">Real-World Impact</span>
                    </div>
                </div>
            </div>
            <div class="pattern-body">
                <div class="pattern-section">
                    <h3>What is Tool Use?</h3>
                    <p>Tool Use (also called Function Calling) allows LLMs to <strong>interact with external systems</strong>. Instead of just generating text, the LLM can request execution of specific functions with parameters.</p>
                </div>

                <div class="pattern-section">
                    <h3>How It Works</h3>
                    <div class="diagram">
                        <div class="diagram-row">
                            <div class="diagram-box">
                                <h4>üë§ User</h4>
                                <span>"Read config.py"</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box highlight">
                                <h4>ü§ñ LLM</h4>
                                <span>Decides to call tool</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box">
                                <h4>üìã Tool Call</h4>
                                <span>read_file("config.py")</span>
                            </div>
                        </div>
                        <div class="diagram-arrow-down">‚Üì</div>
                        <div class="diagram-row">
                            <div class="diagram-box">
                                <h4>üíª Execution</h4>
                                <span>Python function runs</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box">
                                <h4>üìä Result</h4>
                                <span>File contents</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box highlight">
                                <h4>ü§ñ LLM</h4>
                                <span>Formats response</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Implementation Using Decorator Pattern</h3>
                    <div class="code-block">
<pre><span class="keyword">from</span> agno.tools.decorator <span class="keyword">import</span> tool

<span class="decorator">@tool</span>(name=<span class="string">"read_file"</span>)
<span class="keyword">def</span> <span class="function">read_file</span>(
    file_path: str,
    start_line: Optional[int] = <span class="keyword">None</span>,
    end_line: Optional[int] = <span class="keyword">None</span>
) -> str:
    <span class="string">"""
    Read contents of a file.

    Args:
        file_path: Path to the file to read
        start_line: Optional starting line number
        end_line: Optional ending line number

    Returns:
        File contents as a string
    """</span>
    <span class="comment"># The docstring becomes the tool description for the LLM</span>
    <span class="comment"># Type hints become parameter schemas</span>

    path = Path(file_path)
    <span class="keyword">if not</span> path.exists():
        <span class="keyword">return</span> f<span class="string">"Error: File not found: {file_path}"</span>

    content = path.read_text()
    <span class="keyword">return</span> content</pre>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Tool Categories in Code Agent</h3>
                    <table class="comparison">
                        <tr>
                            <th>Category</th>
                            <th>Tools</th>
                            <th>Purpose</th>
                        </tr>
                        <tr>
                            <td><strong>Terminal</strong></td>
                            <td>run_command, cd, pwd, ls</td>
                            <td>Execute shell commands</td>
                        </tr>
                        <tr>
                            <td><strong>File</strong></td>
                            <td>read, write, edit, delete</td>
                            <td>File system operations</td>
                        </tr>
                        <tr>
                            <td><strong>Search</strong></td>
                            <td>grep, find, structure</td>
                            <td>Code exploration</td>
                        </tr>
                        <tr>
                            <td><strong>Git</strong></td>
                            <td>status, commit, push, branch</td>
                            <td>Version control</td>
                        </tr>
                        <tr>
                            <td><strong>Build</strong></td>
                            <td>test, lint, build</td>
                            <td>Development tasks</td>
                        </tr>
                    </table>
                </div>

                <div class="info-box">
                    <h4>üîë Key Insight</h4>
                    <p>The <code>@tool</code> decorator converts Python functions into LLM-callable tools. The docstring becomes the tool description, and type hints define the parameter schema. This is called <strong>schema generation</strong>.</p>
                </div>
            </div>
        </section>

        <!-- Pattern 3: RAG -->
        <section id="rag" class="pattern">
            <div class="pattern-header">
                <div class="pattern-icon">üìö</div>
                <div class="pattern-title">
                    <h2>3. RAG Pattern (Retrieval-Augmented Generation)</h2>
                    <div class="tags">
                        <span class="tag">Context Enhancement</span>
                        <span class="tag">Knowledge Retrieval</span>
                        <span class="tag">Grounding</span>
                    </div>
                </div>
            </div>
            <div class="pattern-body">
                <div class="pattern-section">
                    <h3>What is RAG?</h3>
                    <p>RAG combines <strong>retrieval</strong> (finding relevant information) with <strong>generation</strong> (LLM response). Instead of relying solely on the LLM's training data, we retrieve relevant context and include it in the prompt.</p>
                </div>

                <div class="pattern-section">
                    <h3>RAG Flow in Code Agent</h3>
                    <div class="diagram">
                        <div class="diagram-row">
                            <div class="diagram-box">
                                <h4>‚ùì Query</h4>
                                <span>"Fix the bug in auth"</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box">
                                <h4>üîç Retrieve</h4>
                                <span>Find auth files</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box">
                                <h4>üìÑ Context</h4>
                                <span>auth.py contents</span>
                            </div>
                        </div>
                        <div class="diagram-arrow-down">‚Üì</div>
                        <div class="diagram-row">
                            <div class="diagram-box highlight">
                                <h4>ü§ñ Generate</h4>
                                <span>LLM + Context ‚Üí Fix</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Implementation: Smart Context Window</h3>
                    <div class="code-block">
<pre><span class="keyword">class</span> <span class="class">SmartContextWindow</span>:
    <span class="string">"""Manages what context to include in the prompt."""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, token_budget: int = 32000):
        self.token_budget = token_budget
        self.file_priorities = {
            <span class="string">".py"</span>: 0.9,    <span class="comment"># High priority</span>
            <span class="string">".ts"</span>: 0.9,
            <span class="string">".md"</span>: 0.5,
            <span class="string">".json"</span>: 0.7,
        }

    <span class="keyword">def</span> <span class="function">build_context</span>(self, query: str, workspace: Path) -> str:
        <span class="comment"># 1. Find relevant files based on query</span>
        relevant_files = self.<span class="function">search_files</span>(query, workspace)

        <span class="comment"># 2. Prioritize by importance</span>
        prioritized = self.<span class="function">prioritize</span>(relevant_files)

        <span class="comment"># 3. Fill context within token budget</span>
        context = []
        tokens_used = 0

        <span class="keyword">for</span> file <span class="keyword">in</span> prioritized:
            file_tokens = self.<span class="function">estimate_tokens</span>(file.content)
            <span class="keyword">if</span> tokens_used + file_tokens < self.token_budget:
                context.append(file)
                tokens_used += file_tokens

        <span class="keyword">return</span> self.<span class="function">format_context</span>(context)</pre>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Why RAG Matters</h3>
                    <ul class="benefit-list">
                        <li><strong>Accuracy:</strong> LLM responses are grounded in actual code, not hallucinated</li>
                        <li><strong>Up-to-date:</strong> Always uses current codebase state, not stale training data</li>
                        <li><strong>Relevant:</strong> Only includes context that matters for the current task</li>
                        <li><strong>Token Efficient:</strong> Manages context window to stay within limits</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Pattern 4: Memory Systems -->
        <section id="memory" class="pattern">
            <div class="pattern-header">
                <div class="pattern-icon">üíæ</div>
                <div class="pattern-title">
                    <h2>4. Memory Systems</h2>
                    <div class="tags">
                        <span class="tag">Persistence</span>
                        <span class="tag">Context Continuity</span>
                        <span class="tag">Learning</span>
                    </div>
                </div>
            </div>
            <div class="pattern-body">
                <div class="pattern-section">
                    <h3>Why Memory is Critical</h3>
                    <p>LLMs are <strong>stateless</strong> - they don't remember previous conversations. Memory systems solve this by:</p>
                    <ul class="benefit-list">
                        <li>Maintaining conversation context across interactions</li>
                        <li>Remembering user preferences and past decisions</li>
                        <li>Learning from errors and solutions</li>
                        <li>Enabling long-running development sessions</li>
                    </ul>
                </div>

                <div class="pattern-section">
                    <h3>Three-Layer Memory Architecture</h3>

                    <div class="info-box" style="margin-bottom: 20px;">
                        <h4>Layer 1: Session Memory (Short-Term)</h4>
                        <p><strong>Duration:</strong> Current conversation<br>
                        <strong>Storage:</strong> In-memory + SQLite<br>
                        <strong>Purpose:</strong> Track conversation flow, immediate context</p>
                    </div>

                    <div class="info-box success" style="margin-bottom: 20px;">
                        <h4>Layer 2: Long-Term Memory (Persistent)</h4>
                        <p><strong>Duration:</strong> Across sessions<br>
                        <strong>Storage:</strong> JSON files per project<br>
                        <strong>Purpose:</strong> Remember decisions, errors, solutions</p>
                    </div>

                    <div class="info-box warning">
                        <h4>Layer 3: Smart Context (Dynamic)</h4>
                        <p><strong>Duration:</strong> Per request<br>
                        <strong>Storage:</strong> Computed on-demand<br>
                        <strong>Purpose:</strong> Include relevant code files in context</p>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Memory Entry Structure</h3>
                    <div class="code-block">
<pre><span class="decorator">@dataclass</span>
<span class="keyword">class</span> <span class="class">MemoryEntry</span>:
    id: str                    <span class="comment"># Unique identifier</span>
    timestamp: str             <span class="comment"># When it happened</span>
    type: str                  <span class="comment"># conversation, decision, error, solution</span>
    content: str               <span class="comment"># What happened</span>
    context: Dict              <span class="comment"># Additional metadata</span>
    tags: List[str]            <span class="comment"># Categorization</span>
    project: Optional[str]     <span class="comment"># Which project</span>
    importance: int            <span class="comment"># 1-5 relevance score</span>

<span class="comment"># Example entry</span>
entry = <span class="class">MemoryEntry</span>(
    id=<span class="string">"mem_abc123"</span>,
    timestamp=<span class="string">"2024-01-15T10:30:00"</span>,
    type=<span class="string">"solution"</span>,
    content=<span class="string">"Fixed CORS error by adding middleware"</span>,
    context={<span class="string">"files"</span>: [<span class="string">"server.py"</span>]},
    tags=[<span class="string">"bug-fix"</span>, <span class="string">"cors"</span>],
    project=<span class="string">"my-api"</span>,
    importance=4
)</pre>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Memory Recall Flow</h3>
                    <div class="diagram">
                        <div class="diagram-row">
                            <div class="diagram-box">
                                <h4>‚ùì New Query</h4>
                                <span>"CORS error again"</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box">
                                <h4>üîç Search Memory</h4>
                                <span>Find similar past entries</span>
                            </div>
                            <div class="diagram-arrow">‚Üí</div>
                            <div class="diagram-box highlight">
                                <h4>üí° Recall</h4>
                                <span>"Last time we added middleware"</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-box success">
                    <h4>üéØ Interview Tip</h4>
                    <p>When asked "Why use memory?", explain: LLMs are stateless, memory creates continuity. It's like the difference between talking to someone with amnesia vs. someone who remembers your previous conversations.</p>
                </div>
            </div>
        </section>

        <!-- Pattern 5: Orchestration -->
        <section id="orchestration" class="pattern">
            <div class="pattern-header">
                <div class="pattern-icon">üé≠</div>
                <div class="pattern-title">
                    <h2>5. Agent Orchestration Pattern</h2>
                    <div class="tags">
                        <span class="tag">Multi-Agent</span>
                        <span class="tag">Specialization</span>
                        <span class="tag">Delegation</span>
                    </div>
                </div>
            </div>
            <div class="pattern-body">
                <div class="pattern-section">
                    <h3>Master-Specialist Architecture</h3>
                    <p>Code Agent uses a <strong>hierarchical agent pattern</strong> where a master agent delegates to specialized sub-agents:</p>
                    <div class="diagram">
                        <div class="diagram-row">
                            <div class="diagram-box highlight">
                                <h4>üß† CodingAgent</h4>
                                <span>Master Orchestrator</span>
                            </div>
                        </div>
                        <div class="diagram-arrow-down">‚Üì Delegates to</div>
                        <div class="diagram-row">
                            <div class="diagram-box">
                                <h4>üîç Reviewer</h4>
                                <span>Code quality</span>
                            </div>
                            <div class="diagram-box">
                                <h4>üêõ Debugger</h4>
                                <span>Bug fixing</span>
                            </div>
                            <div class="diagram-box">
                                <h4>üîÑ Refactorer</h4>
                                <span>Code improvement</span>
                            </div>
                            <div class="diagram-box">
                                <h4>üß™ Tester</h4>
                                <span>Test generation</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Specialized Agent Implementation</h3>
                    <div class="code-block">
<pre><span class="keyword">class</span> <span class="class">CodeReviewerAgent</span>(BaseSpecializedAgent):
    <span class="string">"""Specialized agent for code review tasks."""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="keyword">super</span>().__init__(
            name=<span class="string">"CodeReviewer"</span>,
            instructions=<span class="string">"""
            You are an expert code reviewer. Focus on:
            1. Code quality and best practices
            2. Potential bugs and edge cases
            3. Security vulnerabilities
            4. Performance issues
            5. Readability and maintainability
            """</span>,
            tools=[read_file, search_files]  <span class="comment"># Limited tool set</span>
        )

    <span class="keyword">def</span> <span class="function">review</span>(self, file_path: str) -> str:
        <span class="keyword">return</span> self.run(f<span class="string">"Review the code in {file_path}"</span>)</pre>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Why Specialization?</h3>
                    <ul class="benefit-list">
                        <li><strong>Focused Instructions:</strong> Each agent has domain-specific system prompts</li>
                        <li><strong>Limited Tools:</strong> Agents only have tools they need, reducing errors</li>
                        <li><strong>Better Results:</strong> Specialized prompts produce more accurate outputs</li>
                        <li><strong>Maintainability:</strong> Easy to update or add new specialists</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Pattern 6: Streaming -->
        <section id="streaming" class="pattern">
            <div class="pattern-header">
                <div class="pattern-icon">üì°</div>
                <div class="pattern-title">
                    <h2>6. Streaming Response Pattern</h2>
                    <div class="tags">
                        <span class="tag">Real-Time</span>
                        <span class="tag">UX Enhancement</span>
                        <span class="tag">Token-by-Token</span>
                    </div>
                </div>
            </div>
            <div class="pattern-body">
                <div class="pattern-section">
                    <h3>What is Streaming?</h3>
                    <p>Instead of waiting for the entire response, streaming sends tokens <strong>as they are generated</strong>. This creates a "typing" effect and dramatically improves perceived performance.</p>
                </div>

                <div class="pattern-section">
                    <h3>Streaming vs Non-Streaming</h3>
                    <table class="comparison">
                        <tr>
                            <th>Aspect</th>
                            <th>Non-Streaming</th>
                            <th>Streaming</th>
                        </tr>
                        <tr>
                            <td>Time to First Token</td>
                            <td>5-30 seconds (full response)</td>
                            <td>~100ms</td>
                        </tr>
                        <tr>
                            <td>User Experience</td>
                            <td>Long wait, then all at once</td>
                            <td>Immediate feedback, progressive</td>
                        </tr>
                        <tr>
                            <td>Memory Usage</td>
                            <td>Full response in memory</td>
                            <td>Chunk by chunk</td>
                        </tr>
                        <tr>
                            <td>Cancellation</td>
                            <td>Must wait for completion</td>
                            <td>Can stop mid-stream</td>
                        </tr>
                    </table>
                </div>

                <div class="pattern-section">
                    <h3>Implementation</h3>
                    <div class="code-block">
<pre><span class="comment"># Agent configuration with streaming</span>
agent = <span class="class">Agent</span>(
    model=model,
    tools=tools,
    stream=<span class="keyword">True</span>  <span class="comment"># Enable streaming</span>
)

<span class="comment"># Consuming the stream</span>
<span class="keyword">async def</span> <span class="function">process_stream</span>(message: str):
    response = agent.run(message, stream=<span class="keyword">True</span>)

    <span class="keyword">for</span> chunk <span class="keyword">in</span> response:
        <span class="keyword">if</span> chunk.content:
            <span class="comment"># Display immediately</span>
            print(chunk.content, end=<span class="string">""</span>, flush=<span class="keyword">True</span>)

        <span class="keyword">if</span> chunk.tool_calls:
            <span class="comment"># Handle tool execution</span>
            <span class="keyword">for</span> call <span class="keyword">in</span> chunk.tool_calls:
                display_tool_status(call)</pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Pattern 7: Prompt Engineering -->
        <section id="prompt-engineering" class="pattern">
            <div class="pattern-header">
                <div class="pattern-icon">‚ú®</div>
                <div class="pattern-title">
                    <h2>7. Prompt Engineering Patterns</h2>
                    <div class="tags">
                        <span class="tag">System Prompts</span>
                        <span class="tag">Few-Shot</span>
                        <span class="tag">Chain of Thought</span>
                    </div>
                </div>
            </div>
            <div class="pattern-body">
                <div class="pattern-section">
                    <h3>System Prompt Design</h3>
                    <p>The system prompt defines the agent's <strong>personality, capabilities, and constraints</strong>. Code Agent uses a detailed 150+ line system prompt:</p>
                    <div class="code-block">
<pre>CODING_AGENT_INSTRUCTIONS = <span class="string">"""
You are Code Agent, an AI-powered development assistant.

## Core Capabilities
- Read, write, and edit files
- Execute terminal commands
- Search code and navigate projects
- Manage git operations

## Guidelines
1. Always read files before editing
2. Explain changes before making them
3. Use appropriate tools for each task
4. Handle errors gracefully

## Safety Rules
- Never delete without confirmation
- Stay within the workspace directory
- Don't expose sensitive data

## Response Format
- Be concise but thorough
- Use markdown for code blocks
- Show file paths for changes
"""</span></pre>
                    </div>
                </div>

                <div class="pattern-section">
                    <h3>Prompt Engineering Techniques Used</h3>
                    <ul class="benefit-list">
                        <li><strong>Role Definition:</strong> "You are Code Agent, an AI development assistant"</li>
                        <li><strong>Capability Listing:</strong> Explicit list of what the agent can do</li>
                        <li><strong>Constraint Setting:</strong> Safety rules and limitations</li>
                        <li><strong>Format Specification:</strong> How responses should be structured</li>
                        <li><strong>Few-Shot Examples:</strong> Examples in tool docstrings</li>
                    </ul>
                </div>

                <div class="info-box warning">
                    <h4>‚ö†Ô∏è Common Pitfalls</h4>
                    <p>Avoid vague instructions. Instead of "be helpful", specify exactly what helpful means: "always confirm before destructive operations" or "explain the reason for each code change".</p>
                </div>
            </div>
        </section>

        <!-- Interview Q&A Section -->
        <section id="interview-qa">
            <h2 style="margin-bottom: 30px; display: flex; align-items: center; gap: 15px;">
                <span style="background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%); padding: 10px 15px; border-radius: 10px;">üéØ</span>
                Interview Questions & Answers
            </h2>

            <div class="qa-section">
                <h3 style="margin-bottom: 20px; color: var(--primary);">Architecture & Design</h3>

                <div class="qa-item">
                    <div class="question">Explain the architecture of your AI agent project.</div>
                    <div class="answer">
                        "Code Agent is an agentic development environment built with a layered architecture. At the top, we have the <strong>Presentation Layer</strong> (CLI and API) that handles user interaction. The <strong>Agent Layer</strong> contains our CodingAgent orchestrator built on the Agno framework, which coordinates with the <strong>LLM Integration Layer</strong> supporting both Claude and Ollama. The <strong>Tool Layer</strong> provides 15+ tools for file operations, terminal commands, and git. Finally, the <strong>Persistence Layer</strong> handles three types of memory: session memory in SQLite, long-term memory in JSON, and smart context for dynamic file inclusion."
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">What is the ReAct pattern and how do you use it?</div>
                    <div class="answer">
                        "ReAct stands for <strong>Reasoning + Acting</strong>. It's a pattern where the agent thinks about what to do, takes an action, observes the result, and then reasons again. In Code Agent, when a user says 'fix the bug in auth.py', the agent: (1) <strong>Thinks</strong>: 'I need to read the file first', (2) <strong>Acts</strong>: calls read_file('auth.py'), (3) <strong>Observes</strong>: sees the code, (4) <strong>Thinks</strong>: 'I see the issue on line 45', (5) <strong>Acts</strong>: calls edit_file to fix it. This loop continues until the task is complete."
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">Why did you implement a multi-layer memory system?</div>
                    <div class="answer">
                        "LLMs are stateless - they don't remember anything between calls. We needed three layers because each serves a different purpose: <strong>Session Memory</strong> maintains conversation context within a single session (like RAM). <strong>Long-Term Memory</strong> persists important decisions, errors, and solutions across sessions (like a hard drive). <strong>Smart Context</strong> dynamically selects which files to include based on the current query (like L1 cache). This architecture lets the agent learn from past interactions and make contextually-aware decisions."
                    </div>
                </div>
            </div>

            <div class="qa-section">
                <h3 style="margin-bottom: 20px; color: var(--primary);">AI Concepts</h3>

                <div class="qa-item">
                    <div class="question">What is RAG and how does your project use it?</div>
                    <div class="answer">
                        "RAG is <strong>Retrieval-Augmented Generation</strong>. Instead of relying on the LLM's training data, we retrieve relevant information and include it in the context. In Code Agent, when a user asks about their code, we: (1) Search for relevant files using pattern matching, (2) Prioritize files by importance (e.g., .py files score higher), (3) Fill the context window with the most relevant content while staying under token limits, (4) Send this context with the query to the LLM. This grounds the response in actual code rather than hallucinated content."
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">Explain function calling / tool use in LLMs.</div>
                    <div class="answer">
                        "Tool use lets LLMs interact with external systems. Instead of just generating text, the model can request function execution. In Code Agent, we use the <code>@tool</code> decorator to expose Python functions to the LLM. The decorator extracts the function signature and docstring to create a schema. When the LLM decides to use a tool, it outputs a structured JSON with the function name and parameters. Our framework catches this, executes the function, and returns the result to the LLM for further processing. This is how the agent can actually read files, run commands, and make changes."
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">Why use streaming responses?</div>
                    <div class="answer">
                        "Streaming dramatically improves user experience. Without streaming, users wait 5-30 seconds staring at nothing, then get a wall of text. With streaming, they see the first token in ~100ms and watch the response build. This provides immediate feedback that something is happening. Additionally, streaming allows cancellation mid-response if the user sees the agent going in the wrong direction, and it's more memory-efficient since we process chunk by chunk instead of buffering the entire response."
                    </div>
                </div>
            </div>

            <div class="qa-section">
                <h3 style="margin-bottom: 20px; color: var(--primary);">Technical Deep-Dives</h3>

                <div class="qa-item">
                    <div class="question">How do you handle context window limits?</div>
                    <div class="answer">
                        "We use a <strong>Smart Context Window</strong> manager. Each model has a token limit (e.g., 32K for Claude). Our system: (1) Estimates tokens using character count √ó 0.25, (2) Assigns priority scores to files based on extension (.py=0.9, .md=0.5), (3) Auto-includes important files (package.json, pyproject.toml), (4) Fills the budget with highest-priority content first, (5) Truncates or excludes low-priority content if needed. This ensures we maximize useful context without exceeding limits."
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">How does the agent decide which tool to use?</div>
                    <div class="answer">
                        "The LLM makes this decision based on the tool descriptions in the system prompt. Each tool has a detailed docstring explaining what it does, its parameters, and when to use it. For example, the read_file tool says 'Read contents of a file. Use this when you need to see what's in a file.' The LLM's training enables it to match user intents to tool descriptions. If someone says 'show me config.py', the LLM understands this maps to read_file. The Agno framework handles the actual execution once the LLM decides."
                    </div>
                </div>

                <div class="qa-item">
                    <div class="question">What's the difference between your master agent and specialized agents?</div>
                    <div class="answer">
                        "The <strong>CodingAgent</strong> is our master orchestrator - it handles general tasks and delegates to specialists when appropriate. <strong>Specialized agents</strong> like CodeReviewer, Debugger, and Tester have focused system prompts and limited tool sets. For example, CodeReviewer only has read and search tools (no write access) and its prompt focuses entirely on code quality. This specialization produces better results because the agent isn't trying to be everything at once. The master agent recognizes when a task needs specialist help and routes accordingly."
                    </div>
                </div>
            </div>
        </section>

        <!-- Summary Section -->
        <section class="summary-section">
            <h2>üìã Quick Reference Summary</h2>
            <div class="summary-grid">
                <div class="summary-item">
                    <h3>ü§ñ Agent Pattern</h3>
                    <p>Autonomous systems that perceive, decide, and act. Uses ReAct loop for reasoning.</p>
                </div>
                <div class="summary-item">
                    <h3>üîß Tool Use</h3>
                    <p>LLM function calling via @tool decorator. Bridges AI to real-world actions.</p>
                </div>
                <div class="summary-item">
                    <h3>üìö RAG</h3>
                    <p>Retrieval-Augmented Generation. Grounds responses in actual codebase content.</p>
                </div>
                <div class="summary-item">
                    <h3>üíæ Memory</h3>
                    <p>3-layer system: Session (short), Long-term (persistent), Context (dynamic).</p>
                </div>
                <div class="summary-item">
                    <h3>üé≠ Orchestration</h3>
                    <p>Master agent delegates to specialists. Focused prompts yield better results.</p>
                </div>
                <div class="summary-item">
                    <h3>üì° Streaming</h3>
                    <p>Real-time token delivery. ~100ms to first token vs 5-30s wait.</p>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="footer">
            <p>AI Design Patterns Documentation - Code Agent</p>
            <p style="margin-top: 10px;">Prepared for Interview Preparation</p>
        </footer>
    </div>
</body>
</html>
